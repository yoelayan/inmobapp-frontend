---
description: Incluir en la respuesta mejores practicas para el uso de useEffect
globs:
alwaysApply: false
---
# Uso Correcto de useEffect en React y sus Alternativas

El hook `useEffect` es fundamental en React, pero cuando se usa excesivamente o incorrectamente puede causar problemas significativos de rendimiento. Vamos a explorar cu√°ndo deber√≠as usar este hook, cu√°ndo evitarlo y qu√© alternativas existen.

## ¬øCu√°ndo NO deber√≠as usar useEffect?

Existen varios casos donde muchos desarrolladores utilizan `useEffect` innecesariamente, causando renderizaciones adicionales y disminuyendo el rendimiento:

### 1. Para transformar datos para renderizado

**‚ùå Incorrecto:**
```tsx
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

interface TodoListProps {
  todos: Todo[];
  filter: string;
}

function TodoList({ todos, filter }: TodoListProps) {
  const [visibleTodos, setVisibleTodos] = useState<Todo[]>([]);

  // üî¥ Evitar: estado redundante y Effect innecesario
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  return (
    <ul>
      {visibleTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}
    </ul>
  );
}
```

**‚úÖ Correcto:**
```tsx
function TodoList({ todos, filter }: TodoListProps) {
  // ‚úÖ Mejor: c√°lculo directo durante el renderizado
  const visibleTodos = getFilteredTodos(todos, filter);

  return (
    <ul>
      {visibleTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}
    </ul>
  );
}
```

Este enfoque es m√°s eficiente porque evita un ciclo adicional de renderizado.

### 2. Para calcular valores derivados del estado o props

**‚ùå Incorrecto:**
```tsx
interface FormProps {
  initialFirstName?: string;
  initialLastName?: string;
}

function Form({ initialFirstName = 'Taylor', initialLastName = 'Swift' }: FormProps) {
  const [firstName, setFirstName] = useState(initialFirstName);
  const [lastName, setLastName] = useState(initialLastName);
  const [fullName, setFullName] = useState('');

  // üî¥ Evitar: estado redundante y Effect innecesario
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);

  return (
    <form>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </form>
  );
}
```

**‚úÖ Correcto:**
```tsx
function Form({ initialFirstName = 'Taylor', initialLastName = 'Swift' }: FormProps) {
  const [firstName, setFirstName] = useState(initialFirstName);
  const [lastName, setLastName] = useState(initialLastName);

  // ‚úÖ Mejor: calculado durante el renderizado
  const fullName = firstName + ' ' + lastName;

  return (
    <form>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </form>
  );
}
```

Cuando algo puede calcularse a partir de props o estado existente, no lo pongas en estado.

## ¬øCu√°ndo USAR useEffect correctamente?

`useEffect` debe usarse principalmente para:

### 1. Sincronizar con sistemas externos

- Integraci√≥n con bibliotecas externas (como jQuery widgets)
- Suscripciones a APIs o WebSockets
- Manipulaci√≥n directa del DOM

### 2. Control del ciclo de vida del componente

```tsx
interface UserProfileProps {
  userId: string;
}

function UserProfile({ userId }: UserProfileProps) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // C√≥digo ejecutado en montaje o cuando cambia userId
    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Error fetching user:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### 3. Suscripciones y limpieza de recursos

```tsx
interface ChatRoomProps {
  roomId: string;
  userId: string;
}

function ChatRoom({ roomId, userId }: ChatRoomProps) {
  const [messages, setMessages] = useState<Message[]>([]);

  useEffect(() => {
    // Crear conexi√≥n al montar o cuando cambien las dependencias
    const connection = createConnection(roomId, userId);
    connection.connect();

    // Suscribirse a mensajes
    const unsubscribe = connection.subscribe((message: Message) => {
      setMessages(prev => [...prev, message]);
    });

    // Funci√≥n de limpieza (ejecutada en desmontaje)
    return () => {
      unsubscribe();
      connection.disconnect();
    };
  }, [roomId, userId]);

  return (
    <div>
      {messages.map(message => (
        <div key={message.id}>{message.text}</div>
      ))}
    </div>
  );
}
```

## Alternativas para casos espec√≠ficos

### 1. Para c√°lculos costosos: useMemo

Si tienes una operaci√≥n de c√°lculo costosa que solo necesita volver a calcularse cuando cambien ciertas dependencias:

```tsx
import { useMemo, useState } from 'react';

interface TodoListProps {
  todos: Todo[];
  filter: string;
}

function TodoList({ todos, filter }: TodoListProps) {
  const [newTodo, setNewTodo] = useState('');

  // ‚úÖ No recalcula a menos que cambien todos o filter
  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);

  return (
    <div>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
      />
      <ul>
        {visibleTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}
      </ul>
    </div>
  );
}
```

### 2. Resetear todo el estado cuando una prop cambia

En lugar de usar `useEffect` para restablecer estados cuando cambia una prop:

**‚ùå Incorrecto:**
```tsx
interface ProfilePageProps {
  userId: string;
}

function ProfilePage({ userId }: ProfilePageProps) {
  const [comment, setComment] = useState('');

  // üî¥ Evitar: Resetear estado cuando cambia la prop
  useEffect(() => {
    setComment('');
  }, [userId]);

  return (
    <div>
      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
      />
    </div>
  );
}
```

**‚úÖ Correcto:** Usa la prop `key` para forzar un remontaje completo:

```tsx
interface ProfilePageProps {
  userId: string;
}

export default function ProfilePage({ userId }: ProfilePageProps) {
  return (
    <Profile
      userId={userId}
      key={userId} // Cuando cambia userId, React remontar√° el componente
    />
  );
}

function Profile({ userId }: { userId: string }) {
  // ‚úÖ Este y cualquier otro estado se resetear√°n autom√°ticamente
  const [comment, setComment] = useState('');

  return (
    <div>
      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
      />
    </div>
  );
}
```

### 3. Para valores derivados complejos: useMemo con dependencias

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
}

interface ProductListProps {
  products: Product[];
  searchTerm: string;
  selectedCategory: string;
  sortBy: 'name' | 'price';
}

function ProductList({ products, searchTerm, selectedCategory, sortBy }: ProductListProps) {
  // ‚úÖ C√°lculo complejo memoizado
  const filteredAndSortedProducts = useMemo(() => {
    let filtered = products.filter(product =>
      product.name.toLowerCase().includes(searchTerm.toLowerCase()) &&
      (selectedCategory === 'all' || product.category === selectedCategory)
    );

    return filtered.sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      return a.price - b.price;
    });
  }, [products, searchTerm, selectedCategory, sortBy]);

  return (
    <div>
      {filteredAndSortedProducts.map(product => (
        <div key={product.id}>
          <h3>{product.name}</h3>
          <p>${product.price}</p>
        </div>
      ))}
    </div>
  );
}
```

## Problemas comunes con useEffect

### 1. Renders infinitos

Ocurre cuando el efecto actualiza directamente las dependencias en las que se basa, creando un bucle:

```tsx
// üî¥ Causa un bucle infinito
function Counter() {
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    setCounter(counter + 1);
  }, [counter]); // counter cambia ‚Üí efecto se ejecuta ‚Üí counter cambia ‚Üí bucle infinito

  return <div>{counter}</div>;
}
```

### 2. Dependencias omitidas o incorrectas

Siempre incluya todos los valores reactivos usados en el efecto:

```tsx
// üî¥ Incorrecto: userId no est√° incluido en las dependencias
useEffect(() => {
  const connection = createConnection(roomId, userId);
  connection.connect();
  return () => connection.disconnect();
}, [roomId]);

// ‚úÖ Correcto: todos los valores reactivos incluidos
useEffect(() => {
  const connection = createConnection(roomId, userId);
  connection.connect();
  return () => connection.disconnect();
}, [roomId, userId]);
```

### 3. No limpiar recursos

Si un efecto realiza suscripciones o asigna recursos, siempre debe incluir una funci√≥n de limpieza:

```tsx
useEffect(() => {
  const subscription = someAPI.subscribe();

  // ‚úÖ Limpieza adecuada para evitar fugas de memoria
  return () => {
    subscription.unsubscribe();
  };
}, [someAPI]);
```

## Patrones avanzados

### 1. Custom Hook para efectos complejos

```tsx
// hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  // Estado para almacenar nuestro valor
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Funci√≥n para establecer el valor
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue] as const;
}

// Uso
function App() {
  const [name, setName] = useLocalStorage('name', 'John Doe');

  return (
    <input
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

### 2. useEffect con cleanup condicional

```tsx
function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = useRef(callback);

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    if (delay === null) return;

    const id = setInterval(() => savedCallback.current(), delay);

    return () => clearInterval(id);
  }, [delay]);
}

// Uso
function Timer() {
  const [count, setCount] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useInterval(
    () => setCount(c => c + 1),
    isRunning ? 1000 : null
  );

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Start'}
      </button>
    </div>
  );
}
```

## Recomendaci√≥n final

La documentaci√≥n oficial de React lo resume bien: "Remover los Effects innecesarios har√° que tu c√≥digo sea m√°s f√°cil de seguir, m√°s r√°pido de ejecutar y menos propenso a errores".

Antes de usar `useEffect`, preg√∫ntate:

1. ¬øEstoy sincronizando con un sistema externo?
2. ¬øPuedo calcular este valor directamente durante el renderizado?
3. ¬øNecesito realmente este estado o puedo derivarlo de props/estado existente?
4. ¬øHay una alternativa m√°s simple como `useMemo` o la prop `key`?

Siguiendo estas pr√°cticas, tu c√≥digo ser√° m√°s eficiente, mantenible y menos propenso a errores.
